{"remainingRequest":"C:\\Users\\noahl\\Desktop\\Miranda\\miranda\\miranda-client\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!C:\\Users\\noahl\\Desktop\\Miranda\\miranda\\miranda-client\\node_modules\\socket.io-client\\node_modules\\socket.io-parser\\index.js","dependencies":[{"path":"C:\\Users\\noahl\\Desktop\\Miranda\\miranda\\miranda-client\\node_modules\\socket.io-client\\node_modules\\socket.io-parser\\index.js","mtime":1531365523997},{"path":"C:\\Users\\noahl\\Desktop\\Miranda\\miranda\\miranda-client\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1531365509365},{"path":"C:\\Users\\noahl\\Desktop\\Miranda\\miranda\\miranda-client\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1531365501979}],"contextDependencies":[],"result":["\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar debug = require('debug')('socket.io-parser');\r\nvar Emitter = require('component-emitter');\r\nvar binary = require('./binary');\r\nvar isArray = require('isarray');\r\nvar isBuf = require('./is-buffer');\r\n\r\n/**\r\n * Protocol version.\r\n *\r\n * @api public\r\n */\r\n\r\nexports.protocol = 4;\r\n\r\n/**\r\n * Packet types.\r\n *\r\n * @api public\r\n */\r\n\r\nexports.types = [\r\n  'CONNECT',\r\n  'DISCONNECT',\r\n  'EVENT',\r\n  'ACK',\r\n  'ERROR',\r\n  'BINARY_EVENT',\r\n  'BINARY_ACK'\r\n];\r\n\r\n/**\r\n * Packet type `connect`.\r\n *\r\n * @api public\r\n */\r\n\r\nexports.CONNECT = 0;\r\n\r\n/**\r\n * Packet type `disconnect`.\r\n *\r\n * @api public\r\n */\r\n\r\nexports.DISCONNECT = 1;\r\n\r\n/**\r\n * Packet type `event`.\r\n *\r\n * @api public\r\n */\r\n\r\nexports.EVENT = 2;\r\n\r\n/**\r\n * Packet type `ack`.\r\n *\r\n * @api public\r\n */\r\n\r\nexports.ACK = 3;\r\n\r\n/**\r\n * Packet type `error`.\r\n *\r\n * @api public\r\n */\r\n\r\nexports.ERROR = 4;\r\n\r\n/**\r\n * Packet type 'binary event'\r\n *\r\n * @api public\r\n */\r\n\r\nexports.BINARY_EVENT = 5;\r\n\r\n/**\r\n * Packet type `binary ack`. For acks with binary arguments.\r\n *\r\n * @api public\r\n */\r\n\r\nexports.BINARY_ACK = 6;\r\n\r\n/**\r\n * Encoder constructor.\r\n *\r\n * @api public\r\n */\r\n\r\nexports.Encoder = Encoder;\r\n\r\n/**\r\n * Decoder constructor.\r\n *\r\n * @api public\r\n */\r\n\r\nexports.Decoder = Decoder;\r\n\r\n/**\r\n * A socket.io Encoder instance\r\n *\r\n * @api public\r\n */\r\n\r\nfunction Encoder() {}\r\n\r\nvar ERROR_PACKET = exports.ERROR + '\"encode error\"';\r\n\r\n/**\r\n * Encode a packet as a single string if non-binary, or as a\r\n * buffer sequence, depending on packet type.\r\n *\r\n * @param {Object} obj - packet object\r\n * @param {Function} callback - function to handle encodings (likely engine.write)\r\n * @return Calls callback with Array of encodings\r\n * @api public\r\n */\r\n\r\nEncoder.prototype.encode = function(obj, callback){\r\n  debug('encoding packet %j', obj);\r\n\r\n  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {\r\n    encodeAsBinary(obj, callback);\r\n  } else {\r\n    var encoding = encodeAsString(obj);\r\n    callback([encoding]);\r\n  }\r\n};\r\n\r\n/**\r\n * Encode packet as string.\r\n *\r\n * @param {Object} packet\r\n * @return {String} encoded\r\n * @api private\r\n */\r\n\r\nfunction encodeAsString(obj) {\r\n\r\n  // first is type\r\n  var str = '' + obj.type;\r\n\r\n  // attachments if we have them\r\n  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {\r\n    str += obj.attachments + '-';\r\n  }\r\n\r\n  // if we have a namespace other than `/`\r\n  // we append it followed by a comma `,`\r\n  if (obj.nsp && '/' !== obj.nsp) {\r\n    str += obj.nsp + ',';\r\n  }\r\n\r\n  // immediately followed by the id\r\n  if (null != obj.id) {\r\n    str += obj.id;\r\n  }\r\n\r\n  // json data\r\n  if (null != obj.data) {\r\n    var payload = tryStringify(obj.data);\r\n    if (payload !== false) {\r\n      str += payload;\r\n    } else {\r\n      return ERROR_PACKET;\r\n    }\r\n  }\r\n\r\n  debug('encoded %j as %s', obj, str);\r\n  return str;\r\n}\r\n\r\nfunction tryStringify(str) {\r\n  try {\r\n    return JSON.stringify(str);\r\n  } catch(e){\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Encode packet as 'buffer sequence' by removing blobs, and\r\n * deconstructing packet into object with placeholders and\r\n * a list of buffers.\r\n *\r\n * @param {Object} packet\r\n * @return {Buffer} encoded\r\n * @api private\r\n */\r\n\r\nfunction encodeAsBinary(obj, callback) {\r\n\r\n  function writeEncoding(bloblessData) {\r\n    var deconstruction = binary.deconstructPacket(bloblessData);\r\n    var pack = encodeAsString(deconstruction.packet);\r\n    var buffers = deconstruction.buffers;\r\n\r\n    buffers.unshift(pack); // add packet info to beginning of data list\r\n    callback(buffers); // write all the buffers\r\n  }\r\n\r\n  binary.removeBlobs(obj, writeEncoding);\r\n}\r\n\r\n/**\r\n * A socket.io Decoder instance\r\n *\r\n * @return {Object} decoder\r\n * @api public\r\n */\r\n\r\nfunction Decoder() {\r\n  this.reconstructor = null;\r\n}\r\n\r\n/**\r\n * Mix in `Emitter` with Decoder.\r\n */\r\n\r\nEmitter(Decoder.prototype);\r\n\r\n/**\r\n * Decodes an ecoded packet string into packet JSON.\r\n *\r\n * @param {String} obj - encoded packet\r\n * @return {Object} packet\r\n * @api public\r\n */\r\n\r\nDecoder.prototype.add = function(obj) {\r\n  var packet;\r\n  if (typeof obj === 'string') {\r\n    packet = decodeString(obj);\r\n    if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) { // binary packet's json\r\n      this.reconstructor = new BinaryReconstructor(packet);\r\n\r\n      // no attachments, labeled binary but no binary data to follow\r\n      if (this.reconstructor.reconPack.attachments === 0) {\r\n        this.emit('decoded', packet);\r\n      }\r\n    } else { // non-binary full packet\r\n      this.emit('decoded', packet);\r\n    }\r\n  }\r\n  else if (isBuf(obj) || obj.base64) { // raw binary data\r\n    if (!this.reconstructor) {\r\n      throw new Error('got binary data when not reconstructing a packet');\r\n    } else {\r\n      packet = this.reconstructor.takeBinaryData(obj);\r\n      if (packet) { // received final buffer\r\n        this.reconstructor = null;\r\n        this.emit('decoded', packet);\r\n      }\r\n    }\r\n  }\r\n  else {\r\n    throw new Error('Unknown type: ' + obj);\r\n  }\r\n};\r\n\r\n/**\r\n * Decode a packet String (JSON data)\r\n *\r\n * @param {String} str\r\n * @return {Object} packet\r\n * @api private\r\n */\r\n\r\nfunction decodeString(str) {\r\n  var i = 0;\r\n  // look up type\r\n  var p = {\r\n    type: Number(str.charAt(0))\r\n  };\r\n\r\n  if (null == exports.types[p.type]) {\r\n    return error('unknown packet type ' + p.type);\r\n  }\r\n\r\n  // look up attachments if type binary\r\n  if (exports.BINARY_EVENT === p.type || exports.BINARY_ACK === p.type) {\r\n    var buf = '';\r\n    while (str.charAt(++i) !== '-') {\r\n      buf += str.charAt(i);\r\n      if (i == str.length) break;\r\n    }\r\n    if (buf != Number(buf) || str.charAt(i) !== '-') {\r\n      throw new Error('Illegal attachments');\r\n    }\r\n    p.attachments = Number(buf);\r\n  }\r\n\r\n  // look up namespace (if any)\r\n  if ('/' === str.charAt(i + 1)) {\r\n    p.nsp = '';\r\n    while (++i) {\r\n      var c = str.charAt(i);\r\n      if (',' === c) break;\r\n      p.nsp += c;\r\n      if (i === str.length) break;\r\n    }\r\n  } else {\r\n    p.nsp = '/';\r\n  }\r\n\r\n  // look up id\r\n  var next = str.charAt(i + 1);\r\n  if ('' !== next && Number(next) == next) {\r\n    p.id = '';\r\n    while (++i) {\r\n      var c = str.charAt(i);\r\n      if (null == c || Number(c) != c) {\r\n        --i;\r\n        break;\r\n      }\r\n      p.id += str.charAt(i);\r\n      if (i === str.length) break;\r\n    }\r\n    p.id = Number(p.id);\r\n  }\r\n\r\n  // look up json data\r\n  if (str.charAt(++i)) {\r\n    var payload = tryParse(str.substr(i));\r\n    var isPayloadValid = payload !== false && (p.type === exports.ERROR || isArray(payload));\r\n    if (isPayloadValid) {\r\n      p.data = payload;\r\n    } else {\r\n      return error('invalid payload');\r\n    }\r\n  }\r\n\r\n  debug('decoded %s as %j', str, p);\r\n  return p;\r\n}\r\n\r\nfunction tryParse(str) {\r\n  try {\r\n    return JSON.parse(str);\r\n  } catch(e){\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Deallocates a parser's resources\r\n *\r\n * @api public\r\n */\r\n\r\nDecoder.prototype.destroy = function() {\r\n  if (this.reconstructor) {\r\n    this.reconstructor.finishedReconstruction();\r\n  }\r\n};\r\n\r\n/**\r\n * A manager of a binary event's 'buffer sequence'. Should\r\n * be constructed whenever a packet of type BINARY_EVENT is\r\n * decoded.\r\n *\r\n * @param {Object} packet\r\n * @return {BinaryReconstructor} initialized reconstructor\r\n * @api private\r\n */\r\n\r\nfunction BinaryReconstructor(packet) {\r\n  this.reconPack = packet;\r\n  this.buffers = [];\r\n}\r\n\r\n/**\r\n * Method to be called when binary data received from connection\r\n * after a BINARY_EVENT packet.\r\n *\r\n * @param {Buffer | ArrayBuffer} binData - the raw binary data received\r\n * @return {null | Object} returns null if more binary data is expected or\r\n *   a reconstructed packet object if all buffers have been received.\r\n * @api private\r\n */\r\n\r\nBinaryReconstructor.prototype.takeBinaryData = function(binData) {\r\n  this.buffers.push(binData);\r\n  if (this.buffers.length === this.reconPack.attachments) { // done with buffer list\r\n    var packet = binary.reconstructPacket(this.reconPack, this.buffers);\r\n    this.finishedReconstruction();\r\n    return packet;\r\n  }\r\n  return null;\r\n};\r\n\r\n/**\r\n * Cleans up binary packet reconstruction variables.\r\n *\r\n * @api private\r\n */\r\n\r\nBinaryReconstructor.prototype.finishedReconstruction = function() {\r\n  this.reconPack = null;\r\n  this.buffers = [];\r\n};\r\n\r\nfunction error(msg) {\r\n  return {\r\n    type: exports.ERROR,\r\n    data: 'parser error: ' + msg\r\n  };\r\n}\r\n",null]}